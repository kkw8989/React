2024.09.24.

import React from "react";  --> 노드 모듈 패키지
import MyComponent from "./MyComponent"; -->　보통 변수 이름을 파일명으로 통일

const App = () => {
  return (
   <div>
    <MyComponent name="zzzz" age="30">
     리액트 
    </MyComponent>
   </div>
  );
};

export default App;

import React from "react";
import PropTypes from "prop-types";

const MyComponent = ({ name, children, age }) => {
  return (
   <div>
    {name}나의 첫 컴포넌트
    <br />
    자식의 값은 {children}
    <br />내 나이는 {age}
   </div>
  );
};

MyComponent.propTypes = {
  name: PropTypes.string,
};

MyComponent.defaultProps = {
  name: "기본이름",
};

export default MyComponent;  --> 외부 MyComponent 가져온다

------------------------------------------------------------------------

import React, { Component } from 'react';

class MyComponent_c extends Component {
   
   static propTypes = { name: PropTypes.string,
			   age : PropTypes.string.isRequied, --> 무조건 써야함
			};

   static defaultProps = { name: "기본이름",};

   //static은 내장 되어 있어서 강한 결합임

   render() {
     const { name, children, age } = this.props;this -> MyComponent_c가리킴
     return (
       <div>
         {name}나의 첫 컴포넌트
         <br />
         자식의 값은 {children}
         <br />내 나이는 {age}
       </div>
     );
   }
}
export default MyComponent_c;

crtl j -> termenial 키기
yarn start누르면 웹 켜지는데 그게 서버가 돌아가는 것 -> 끄면 안됨 
ctrl s 누르면 알아서 반영됨

static으로 선언한 propTypes와 defaultProps를 클래스의 인스턴스x, 클래스 자체에 정의됨
인스턴스마다 불필요하게 중복되는 값을 피할 수 있음
why? propTypes와 defaultProps는 여러 인스턴스가 공유할 수 있는 정보이기 때문에 인스턴스가 생성될 때마다 복사할 필요가 없다
static으로 선언 -> 메모리 절약 가능
------------------------------------------------------------------------

import React, { Component } from 'react';

class Counter_c extends Component {
   //constructor(props){ cons : 상속받아서 변수 만들 때 받기 위한 메서드 
     super(props);
     this.//state = { state : 변화가 일어나는 변수를 선언할 때
   // cons ~ this. 까지 없애도 잘 나옴
       number : 0, -> 숫자 초기화
       fixedNumber : 0,
     };
   }
   render() {
     // state 값 조회할 때 this.state로 조회
     const { number, fixedNumber } = this.state;
     return (
       <div>
         <h1>{number}</h1>
	  <h2>{fixedNumber}</h2>
	  {/* 버튼 클릭 했을때 실행되는 함수 지정 */}
         <button onClick = {() => 
	  // this.setState를 통해 새로운 값 넣을 수 있다.
	  {this.setState({ number : number +1});}}
          this.setState({ number : this.state.number +1});}}
         // 위에 2개는 똑같은 코드임
           this.setState(prevState => ({ number: prevState.number + 1 }));
          >+1</button> // -> setState : number를 업데이트 시키겠다, 
				key, value는 객체로 감쌀 수 있다.
       </div>
     );
   }
}

export default Counter_c;



클래스형 컴포넌트에서 this를 붙여야만 하고 함수 컴포넌트는 this를 붙이지 않는다
why? 클래스형에서 this를 사용하는 이유는 클래스 내부에서 상태(state)와 메서드를 정의함
클래스 내부에서 정의된 메서드는 속성에 접근하기 위해 this를 사용해야 한다.

함수 컴포넌트에서 this가 필요 없는 이유 : 함수로 정의되어 있기 때문에 호출해서 사용할 수 있음
상태관리를 위해 16.8ver 이후 Hooks가 생겨 클래스 내부에서 접근하여 사용하지 않아도 되기 때문

------------------------------------------------------------------------

# setState가 끝난 후 특정 작업 실행하기 

setState를 사용해서 값을 업데이트하고 난 다음
특정 작업을 하고 싶을 때는 setState의 두 번째 파라미터로 콜 백 함수를 등록하여 작업 처리

 this.setState({ number : number + 1}, () => {
               // () : 콜 백 함수
               console.log('방금 setState가 호출되었습니다');
               console.log(this.state);
             });

------------------------------------------------------------------------


import React, { useState } from 'react';

const Say = () => {
  const [message, setMessage] = useState("");  
  //함수 comp못써서 useState함수 사용, 기존 message를 업데이트 하기 위해 	         setMessage로 씀, 초기값 useState에 문자 초기화
  const [color, setColor] = useState('black');
  const onClickEnter = () => setMessage('Hello~');
  const onClickLeave = () => setMessage('~bye bye');

  return (
   <div>
    <button onClick = {onClickEnter}>입장</button>
    {/* on ClickEnter에 소괄호 쓰면 안 됨 
	-> 함수 호출인데 그 위치로 가자마자 바로 호출  */}
     <button onClick = {onClickLeave}>퇴장</button>
    <h1 style = {{ color }}>{message}</h1>
	{message}는 중괄호가 하나니까 문자인 black을 받음、객체 받는　게 아님!
    <button style = {{ color : 'red'}} onClick = { () => 					setColor('red')}>red</button>
	이 {{}} 속성의 특성을 봐야함 -> 객체를 받음 -> 
	위에서 string으로 받는지 객체인지 헷갈리면 타입을 봐야함
    <button style = {{ color : 'green'}} onClick = { () => 					setColor('green')}>green</button>
    <button style = {{ color : 'blue'}} onClick = { () => 					setColor('blue')}>blue</button>
   </div>
  );
};
export default Say;

------------------------------------------------------------------------

const object = {a:1, b:2, c:3};
const nextObject = {...object, b:4};  --> b : 4로 나옴 객체의 속성 값 변경 O

concat메서드 :  삽입 -> 두 개 이상의 배열을 합치고 새 배열로 출력 
filter메서드 : 삭제 -> (item => item.id !== 3) --> id가 3인거 빼고 다 나와라
map메서드 : 업데이트 -> map(item => item.id === 1 ? {...item, value : false} : item));
